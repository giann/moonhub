local assert=assert;local a,b,c,d=math.sqrt,math.cos,math.sin,math.atan2;local e={}e.__index=e;local function f(g,h)return setmetatable({x=g or 0,y=h or 0},e)end;local i=f(0,0)local function j(k,l)return f(b(k)*l,c(k)*l)end;local function m(n)return type(n)=='table'and type(n.x)=='number'and type(n.y)=='number'end;function e:clone()return f(self.x,self.y)end;function e:unpack()return self.x,self.y end;function e:__tostring()return"("..tonumber(self.x)..","..tonumber(self.y)..")"end;function e.__unm(o)return f(-o.x,-o.y)end;function e.__add(o,p)assert(m(o)and m(p),"Add: wrong argument types (<vector> expected)")return f(o.x+p.x,o.y+p.y)end;function e.__sub(o,p)assert(m(o)and m(p),"Sub: wrong argument types (<vector> expected)")return f(o.x-p.x,o.y-p.y)end;function e.__mul(o,p)if type(o)=="number"then return f(o*p.x,o*p.y)elseif type(p)=="number"then return f(p*o.x,p*o.y)else assert(m(o)and m(p),"Mul: wrong argument types (<vector> or <number> expected)")return o.x*p.x+o.y*p.y end end;function e.__div(o,p)assert(m(o)and type(p)=="number","wrong argument types (expected <vector> / <number>)")return f(o.x/p,o.y/p)end;function e.__eq(o,p)return o.x==p.x and o.y==p.y end;function e.__lt(o,p)return o.x<p.x or o.x==p.x and o.y<p.y end;function e.__le(o,p)return o.x<=p.x and o.y<=p.y end;function e.permul(o,p)assert(m(o)and m(p),"permul: wrong argument types (<vector> expected)")return f(o.x*p.x,o.y*p.y)end;function e:toPolar()return f(d(self.x,self.y),self:len())end;function e:len2()return self.x*self.x+self.y*self.y end;function e:len()return a(self.x*self.x+self.y*self.y)end;function e.dist(o,p)assert(m(o)and m(p),"dist: wrong argument types (<vector> expected)")local q=o.x-p.x;local r=o.y-p.y;return a(q*q+r*r)end;function e.dist2(o,p)assert(m(o)and m(p),"dist: wrong argument types (<vector> expected)")local q=o.x-p.x;local r=o.y-p.y;return q*q+r*r end;function e:normalizeInplace()local s=self:len()if s>0 then self.x,self.y=self.x/s,self.y/s end;return self end;function e:normalized()return self:clone():normalizeInplace()end;function e:rotateInplace(t)local u,v=b(t),c(t)self.x,self.y=u*self.x-v*self.y,v*self.x+u*self.y;return self end;function e:rotated(t)local u,v=b(t),c(t)return f(u*self.x-v*self.y,v*self.x+u*self.y)end;function e:perpendicular()return f(-self.y,self.x)end;function e:projectOn(n)assert(m(n),"invalid argument: cannot project vector on "..type(n))local v=(self.x*n.x+self.y*n.y)/(n.x*n.x+n.y*n.y)return f(v*n.x,v*n.y)end;function e:mirrorOn(n)assert(m(n),"invalid argument: cannot mirror vector on "..type(n))local v=2*(self.x*n.x+self.y*n.y)/(n.x*n.x+n.y*n.y)return f(v*n.x-self.x,v*n.y-self.y)end;function e:cross(n)assert(m(n),"cross: wrong argument types (<vector> expected)")return self.x*n.y-self.y*n.x end;function e:trimInplace(w)local v=w*w/self:len2()v=v>1 and 1 or math.sqrt(v)self.x,self.y=self.x*v,self.y*v;return self end;function e:angleTo(x)if x then return d(self.y,self.x)-d(x.y,x.x)end;return d(self.y,self.x)end;function e:trimmed(w)return self:clone():trimInplace(w)end;return setmetatable({new=f,fromPolar=j,isvector=m,zero=i},{__call=function(y,...)return f(...)end})
